package GraphFramework;
import java.util.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import phonenetworkapp.BluePrintsGraph;

public class KruskalAlg extends MSTAlgorithm {

    static List<Edge> minspanningtree;
    int totalCost;
 

    public KruskalAlg(BluePrintsGraph graph) {

       
    }

    public KruskalAlg() {
    }

    public static List<Edge> kruskal(Graph graph) {

//        initilize the minspanningtree
       minspanningtree = new ArrayList<>();
       
       //Create to lists of vetices and edges 
       LinkedList<Vertex> verticesList  = Graph.vertices; 
       LinkedList<Edge> EdgeList = Vertex.adjList;
//       
        DisjointSet disjointSet = new DisjointSet(verticesList);

        Collections.sort(EdgeList);

        for (Edge edge : EdgeList) {
            String a = edge.getSource().getLabel();
            String b = edge.getTarget().getLabel();

            // System.out.println("u is "+a+" v is "+b); this line is for testing
        }

        for (Edge edge : EdgeList) {
            Vertex u = (Vertex) edge.getSource();
            Vertex v = (Vertex) edge.getTarget();

            if (!disjointSet.find(u).equals(disjointSet.find(v))) {
                minspanningtree.add(edge);
                disjointSet.union(u, v);
            }
        }

        return minspanningtree;
    }

    @Override
    public void displayResultingMST() {
        System.out.println("The phone network (minimum spanning tree) generated by Kruskal algorithm is as follows:");

        for (int i = 0; i < minspanningtree.size(); i++) {
            totalCost += minspanningtree.get(i).getWeight();

//            Vertex sour = minspanningtree.get(i).getSource();
//            sour.dispalyInfo(sour);
//            System.out.print(" - ");
//            Vertex des = minspanningtree.get(i).getTarget();
//            des.dispalyInfo(des);   
//            Line ed = (Line) minspanningtree.get(i);
//            ed.dispalyInfo(ed);
        }

        System.out.println("\nThe cost of designed phone network: " + totalCost + "\n");
    }
}

class DisjointSet {

    private Map<Vertex, Vertex> parent;

    public DisjointSet(List<Vertex> vertices) {
        parent = new HashMap<>();
        for (Vertex vertex : vertices) {
            parent.put(vertex, vertex);
        }
    }

    public Vertex find(Vertex vertex) {

        if (parent.get(vertex).equals(vertex)) {
            return vertex;
        }
        return find(parent.get(vertex));
    }

    public void union(Vertex x, Vertex y) {
        Vertex xRoot = find(x);
        Vertex yRoot = find(y);
        parent.put(xRoot, yRoot);
    }
}
