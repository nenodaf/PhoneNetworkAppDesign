package GraphFramework;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import phonenetworkapp.BluePrintsGraph;

public class MHPrimAlg extends MSTAlgorithm {

    List<Edge> mst;

    int totalCost;
    Set<Vertex> visited;
    PriorityQueue<Edge> minHeap;
    LinkedList<Vertex> verticesList;
    LinkedList<Edge> EdgeList;

    public MHPrimAlg(BluePrintsGraph graph1) {
        // initilize the MST and the visited set
        mst = new ArrayList<>();
        visited = new HashSet<>();

        //create a priority queue for the minheap and compare the weigths for the edges
        minHeap = new PriorityQueue<>(Comparator.comparingInt(Edge::getWeight));

        //Create to lists of vetices and edges to use them
        verticesList = Graph.vertices;

        EdgeList = Vertex.adjList;
        for (int i = 0; i < EdgeList.size(); i++) {
            for (int j = 0; j < EdgeList.size(); j++) {
                if (EdgeList.get(i).getSource() == EdgeList.get(j).getTarget() && EdgeList.get(i).getTarget() == EdgeList.get(j).getSource()) {
                    EdgeList.remove(EdgeList.get(j));
                }
            }
        }
    }

    /**
     *
     * @param graph
     * @return
     */
    public List<Edge> primMST(Graph graph) {
        //Create to lists of vetices and edges to use them
        verticesList = Graph.vertices;
        //get the first vertex to start the MST from it
        Vertex startVertex = verticesList.get(0);

        //This map for the edge weigths
        Map<Edge, Integer> edgeWeights = new HashMap<>();

        //add all the edges with their weights to edgeWeights map
        for (Edge e : EdgeList) {
            edgeWeights.put(e, e.getWeight());
        }

        //add the start vertex to the visited set
        visited.add(startVertex);

        String start_Vertex = startVertex.getLabel();
        System.out.println("starting vertex " + start_Vertex);
        //add all the edges that are connected to start vertex to the priorityQueue minHeap
        for (int i = 0; i < EdgeList.size(); i++) {

            minHeap.offer(startVertex.getAdjList().get(i));
        }

        //Repeat until wa add all the vertices to the minimum spanning tree
        while (visited.size() < verticesList.size()) {
            //get the edge with minimum weight from the priorityQueue
            Edge minEdge = minHeap.poll();

            //check if the target vetex is visited or not, if visited just skip it
            if (visited.contains(minEdge.getTarget())) {
                continue;
            }

            // add the edge to mst and mark it as visited by adding the edge to visited set
            mst.add(minEdge);
            visited.add(minEdge.getTarget());
            // for tracing 
            //String add_Edge=minEdge.getSource().getLabel()+"-->"+minEdge.getTarget();

            //Update all the weight of the edges that starts from the target vertex
            Vertex dest = minEdge.getTarget();

            //create a list of the edges of the target vertex
            List<Edge> edgesFromTarget = dest.getAdjList();

            //get the adjList of edges from the destination vertex
            for (Edge e : edgesFromTarget) {
                if (!visited.contains(e.getTarget())) {
                    //Get the new weight
                    int newWeight = e.getWeight();
                    //check if the weight is less than edge weight 
                    if (newWeight < edgeWeights.get(e)) {
                        minHeap.remove(e);
                        minHeap.offer(e);
                        edgeWeights.put(e, newWeight);
                    }
                }
            }
        }
        //return the minimmun spanning tree
        return mst;
    }

    @Override
    public void displayResultingMST() {
        System.out.println(" The phone network (minimum spanning tree) generated by min-heap based Prim algorithm is as follows:");

        for (int i = 0; i < mst.size(); i++) {
            totalCost += mst.get(i).getWeight();
//
//            Vertex sour = mst.get(i).getSource();
//            sour.dispalyInfo(sour);
//            System.out.print(" - ");
//            Vertex des = mst.get(i).getTarget();
//            des.dispalyInfo(des);
//
//            Line ed = (Line) mst.get(i);
//            ed.dispalyInfo(ed);
        }

        System.out.println("\nThe cost of designed phone network: " + totalCost + "\n");
    }
}
